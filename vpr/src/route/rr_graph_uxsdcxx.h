/*
 * This file is generated by uxsdcxx 0.0.4.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: uxsdcxx.py rr_graph.xsd
 * Input file: /home/duck2/uxsdcxx/rr_graph.xsd
 * md5sum of input file: 86ad1829ffcbd56309275e329a54a96f
 */

#include <bitset>
#include <cassert>
#include <cstring>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include <error.h>
#include <stddef.h>
#include <stdint.h>
#include "pugixml.hpp"

/**
 * Stores a vector of elements in a shared pool. Consists
 * of an offset into the pool and a size. It's faster than a regular
 * vector, but one can only insert into it when it's the last vector
 * in the pool.
 */
template<class T, std::vector<T> &pool>
class collapsed_vec {
private:
	uint32_t _size;
	uint32_t _offset;
public:
	inline collapsed_vec(){
		_size = 0;
		_offset = pool.size();
	}
	inline T& back(){
		return pool[_offset+_size-1];
	}
	inline T* begin(){
		return &pool[_offset];
	}
	inline T* end(){
		return &pool[_offset+_size];
	}
	inline T& operator[](uint32_t i){
		return pool[_offset+i];
	}
	inline void push_back(const T &x){
		assert(_size+_offset == pool.size());
		pool.push_back(x);
		_size++;
	}
	inline uint32_t size(){
		return _size;
	}
};

/**
 * A pool for string data. It manages memory in a vector of chunks
 * with used and size information. The chunk sizes increase exponentially
 * with every new chunk.
 */
class char_pool_impl {
private:
	const uint32_t INITIAL_SIZE = 1024;
	struct chunk {
		uint32_t used;
		uint32_t size;
		char * mem;
	};
	std::vector<chunk> chunks;
public:
	inline char_pool_impl(){
		chunk c;
		c.used = 0;
		c.size = INITIAL_SIZE;
		c.mem = (char *)std::malloc(INITIAL_SIZE);
		chunks.emplace_back(c);
	}
	inline ~char_pool_impl(){
		for(auto &c: chunks)
			free(c.mem);
	}
	/**
	 * Copies x into the string pool and returns a pointer to it.
	 * If x is not small enough to fit in any chunk, a new chunk is
	 * allocated with the size of max(len(x), last chunk's size*2).
	 */
	inline const char *add(const char *x){
		uint32_t len = std::strlen(x)+1;
		char *out;
		for(auto &c: chunks){
			if(c.used+len <= c.size){
				out = &c.mem[c.used];
				c.used += len;
				std::memcpy(out, x, len);
				return out;
			}
		}
		chunk n;
		n.used = len;
		n.size = std::max(chunks.back().size*2, len);
		n.mem = (char *)std::malloc(n.size);
		std::memcpy(n.mem, x, len);
		chunks.emplace_back(n);
		return n.mem;
	}
	/**
	 * Frees all chunks except the first one and leaves the pool
	 * in a usable state.
	 */
	inline void clear(){
		for(uint32_t i=1; i<chunks.size(); i++){
			free(chunks[i].mem);
		}
		chunks.resize(1);
		chunks[0].used = 0;
		std::memset(chunks[0].mem, 0, INITIAL_SIZE);
	}
};

/* All uxsdcxx functions and structs live in this namespace. */
namespace uxsd {

/* Forward decl of generated data types. Needed for the pools.
 * The types are sorted according to tree height, so that the "root type"
 * appears last and we don't get any "incomplete type" errors. */
struct t_channel;
struct t_x_list;
struct t_y_list;
struct t_timing;
struct t_sizing;
struct t_switch;
struct t_segment_timing;
struct t_segment;
struct t_pin;
struct t_pin_class;
struct t_meta;
struct t_metadata;
struct t_block_type;
struct t_grid_loc;
struct t_node_loc;
struct t_node_timing;
struct t_node_segment;
struct t_node_connection_box;
struct t_node_canonical_loc;
struct t_node;
struct t_edge;
struct t_channels;
struct t_switches;
struct t_segments;
struct t_block_types;
struct t_grid_locs;
struct t_rr_nodes;
struct t_rr_edges;
struct t_bin_nodes;
struct t_connection_box;
struct t_connection_boxes;
struct t_rr_graph;

/* Global shared pools for storing multiply-occurring elements. */
extern std::vector <t_pin> pin_pool;
extern std::vector <t_meta> meta_pool;
extern std::vector <t_pin_class> pin_class_pool;
extern std::vector <t_x_list> x_list_pool;
extern std::vector <t_y_list> y_list_pool;
extern std::vector <t_switch> switch_pool;
extern std::vector <t_segment> segment_pool;
extern std::vector <t_block_type> block_type_pool;
extern std::vector <t_grid_loc> grid_loc_pool;
extern std::vector <t_node> node_pool;
extern std::vector <t_edge> edge_pool;
extern std::vector <t_connection_box> connection_box_pool;

extern char_pool_impl char_pool;

/* Helper function for freeing the pools. */
void clear_pools(void);
/* One may want to use the allocated strings after loading, so this
 * function is provided separately. */
void clear_strings(void);

/* Enum tokens generated from XSD enumerations. */
enum class enum_switch_type {UXSD_INVALID = 0, MUX, TRISTATE, PASS_GATE, SHORT, BUFFER};
enum class enum_pin_type {UXSD_INVALID = 0, OPEN, OUTPUT, INPUT};
enum class enum_loc_side {UXSD_INVALID = 0, LEFT, RIGHT, TOP, BOTTOM};
enum class enum_node_type {UXSD_INVALID = 0, CHANX, CHANY, SOURCE, SINK, OPIN, IPIN};
enum class enum_node_direction {UXSD_INVALID = 0, INC_DIR, DEC_DIR, BI_DIR};

/* Structs generated from complex types. */

/** Generated from:
 * <xs:complexType name="channel">
 *   <xs:attribute name="chan_width_max" type="xs:int" use="required" />
 *   <xs:attribute name="x_min" type="xs:int" use="required" />
 *   <xs:attribute name="y_min" type="xs:int" use="required" />
 *   <xs:attribute name="x_max" type="xs:int" use="required" />
 *   <xs:attribute name="y_max" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_channel {
	int chan_width_max;
	int x_max;
	int x_min;
	int y_max;
	int y_min;
};

/** Generated from:
 * <xs:complexType name="x_list">
 *   <xs:attribute name="index" type="xs:unsignedInt" use="required" />
 *   <xs:attribute name="info" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_x_list {
	unsigned int index;
	int info;
};

/** Generated from:
 * <xs:complexType name="y_list">
 *   <xs:attribute name="index" type="xs:unsignedInt" use="required" />
 *   <xs:attribute name="info" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_y_list {
	unsigned int index;
	int info;
};

/** Generated from:
 * <xs:complexType name="timing">
 *   <xs:attribute name="R" type="xs:float" use="required" />
 *   <xs:attribute name="Cin" type="xs:float" use="required" />
 *   <xs:attribute name="Cinternal" type="xs:float" use="required" />
 *   <xs:attribute name="Cout" type="xs:float" use="required" />
 *   <xs:attribute name="Tdel" type="xs:float" use="required" />
 * </xs:complexType>
*/
struct t_timing {
	float Cin;
	float Cinternal;
	float Cout;
	float R;
	float Tdel;
};

/** Generated from:
 * <xs:complexType name="sizing">
 *   <xs:attribute name="mux_trans_size" type="xs:float" use="required" />
 *   <xs:attribute name="buf_size" type="xs:float" use="required" />
 * </xs:complexType>
*/
struct t_sizing {
	float buf_size;
	float mux_trans_size;
};

/** Generated from:
 * <xs:complexType name="switch">
 *   <xs:all>
 *     <xs:element minOccurs="0" name="timing" type="timing" />
 *     <xs:element name="sizing" type="sizing" />
 *   </xs:all>
 *   <xs:attribute name="id" type="xs:int" use="required" />
 *   <xs:attribute name="name" type="xs:string" use="required" />
 *   <xs:attribute name="type" type="switch_type" />
 * </xs:complexType>
*/
struct t_switch {
	int id;
	const char * name;
	enum_switch_type type;
	bool has_timing;
	t_timing timing;
	t_sizing sizing;
};

/** Generated from:
 * <xs:complexType name="segment_timing">
 *   <xs:attribute name="R_per_meter" type="xs:float" />
 *   <xs:attribute name="C_per_meter" type="xs:float" />
 * </xs:complexType>
*/
struct t_segment_timing {
	float C_per_meter;
	float R_per_meter;
};

/** Generated from:
 * <xs:complexType name="segment">
 *   <xs:all>
 *     <xs:element minOccurs="0" name="timing" type="segment_timing" />
 *   </xs:all>
 *   <xs:attribute name="id" type="xs:int" use="required" />
 *   <xs:attribute name="name" type="xs:string" use="required" />
 * </xs:complexType>
*/
struct t_segment {
	int id;
	const char * name;
	bool has_timing;
	t_segment_timing timing;
};

/** Generated from:
 * <xs:complexType name="pin">
 *   <xs:simpleContent>
 *     <xs:extension base="xs:string">
 *       <xs:attribute name="ptc" type="xs:int" use="required" />
 *     </xs:extension>
 *   </xs:simpleContent>
 * </xs:complexType>
*/
struct t_pin {
	int ptc;
	const char * value;
};

/** Generated from:
 * <xs:complexType name="pin_class">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="pin" type="pin" />
 *   </xs:sequence>
 *   <xs:attribute name="type" type="pin_type" use="required" />
 * </xs:complexType>
*/
struct t_pin_class {
	enum_pin_type type;
	collapsed_vec<t_pin, pin_pool> pins;
};

/** Generated from:
 * <xs:complexType name="meta">
 *   <xs:simpleContent>
 *     <xs:extension base="xs:string">
 *       <xs:attribute name="name" type="xs:string" use="required" />
 *     </xs:extension>
 *   </xs:simpleContent>
 * </xs:complexType>
*/
struct t_meta {
	const char * name;
	const char * value;
};

/** Generated from:
 * <xs:complexType name="metadata">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="meta" type="meta" />
 *   </xs:sequence>
 * </xs:complexType>
*/
struct t_metadata {
	collapsed_vec<t_meta, meta_pool> metas;
};

/** Generated from:
 * <xs:complexType name="block_type">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" minOccurs="0" name="pin_class" type="pin_class" />
 *   </xs:sequence>
 *   <xs:attribute name="id" type="xs:int" use="required" />
 *   <xs:attribute name="name" type="xs:string" use="required" />
 *   <xs:attribute name="width" type="xs:int" use="required" />
 *   <xs:attribute name="height" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_block_type {
	int height;
	int id;
	const char * name;
	int width;
	collapsed_vec<t_pin_class, pin_class_pool> pin_classes;
};

/** Generated from:
 * <xs:complexType name="grid_loc">
 *   <xs:attribute name="x" type="xs:int" use="required" />
 *   <xs:attribute name="y" type="xs:int" use="required" />
 *   <xs:attribute name="block_type_id" type="xs:int" use="required" />
 *   <xs:attribute name="width_offset" type="xs:int" use="required" />
 *   <xs:attribute name="height_offset" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_grid_loc {
	int block_type_id;
	int height_offset;
	int width_offset;
	int x;
	int y;
};

/** Generated from:
 * <xs:complexType name="node_loc">
 *   <xs:attribute name="xlow" type="xs:int" use="required" />
 *   <xs:attribute name="ylow" type="xs:int" use="required" />
 *   <xs:attribute name="xhigh" type="xs:int" use="required" />
 *   <xs:attribute name="yhigh" type="xs:int" use="required" />
 *   <xs:attribute name="side" type="loc_side" />
 *   <xs:attribute name="ptc" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_node_loc {
	int ptc;
	enum_loc_side side;
	int xhigh;
	int xlow;
	int yhigh;
	int ylow;
};

/** Generated from:
 * <xs:complexType name="node_timing">
 *   <xs:attribute name="R" type="xs:float" use="required" />
 *   <xs:attribute name="C" type="xs:float" use="required" />
 * </xs:complexType>
*/
struct t_node_timing {
	float C;
	float R;
};

/** Generated from:
 * <xs:complexType name="node_segment">
 *   <xs:attribute name="segment_id" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_node_segment {
	int segment_id;
};

/** Generated from:
 * <xs:complexType name="node_connection_box">
 *   <xs:attribute name="id" type="xs:int" use="required" />
 *   <xs:attribute name="x" type="xs:int" use="required" />
 *   <xs:attribute name="y" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_node_connection_box {
	int id;
	int x;
	int y;
};

/** Generated from:
 * <xs:complexType name="node_canonical_loc">
 *   <xs:attribute name="x" type="xs:int" use="required" />
 *   <xs:attribute name="y" type="xs:int" use="required" />
 * </xs:complexType>
*/
struct t_node_canonical_loc {
	int x;
	int y;
};

/** Generated from:
 * <xs:complexType name="node">
 *   <xs:all>
 *     <xs:element name="loc" type="node_loc" />
 *     <xs:element minOccurs="0" name="timing" type="node_timing" />
 *     <xs:element minOccurs="0" name="segment" type="node_segment" />
 *     <xs:element minOccurs="0" name="connection_box" type="node_connection_box" />
 *     <xs:element minOccurs="0" name="canonical_loc" type="node_canonical_loc" />
 *     <xs:element minOccurs="0" name="metadata" type="metadata" />
 *   </xs:all>
 *   <xs:attribute name="id" type="xs:unsignedInt" use="required" />
 *   <xs:attribute name="type" type="node_type" use="required" />
 *   <xs:attribute name="direction" type="node_direction" />
 *   <xs:attribute name="capacity" type="xs:unsignedInt" use="required" />
 * </xs:complexType>
*/
struct t_node {
	unsigned int capacity;
	enum_node_direction direction;
	unsigned int id;
	enum_node_type type;
	t_node_loc loc;
	bool has_timing;
	t_node_timing timing;
	bool has_segment;
	t_node_segment segment;
	bool has_connection_box;
	t_node_connection_box connection_box;
	bool has_canonical_loc;
	t_node_canonical_loc canonical_loc;
	bool has_metadata;
	t_metadata metadata;
};

/** Generated from:
 * <xs:complexType name="edge">
 *   <xs:all>
 *     <xs:element minOccurs="0" name="metadata" type="metadata" />
 *   </xs:all>
 *   <xs:attribute name="id" type="xs:unsignedInt" />
 *   <xs:attribute name="src_node" type="xs:unsignedInt" use="required" />
 *   <xs:attribute name="sink_node" type="xs:unsignedInt" use="required" />
 *   <xs:attribute name="switch_id" type="xs:unsignedInt" use="required" />
 * </xs:complexType>
*/
struct t_edge {
	unsigned int id;
	unsigned int sink_node;
	unsigned int src_node;
	unsigned int switch_id;
	bool has_metadata;
	t_metadata metadata;
};

/** Generated from:
 * <xs:complexType name="channels">
 *   <xs:sequence>
 *     <xs:element name="channel" type="channel" />
 *     <xs:element maxOccurs="unbounded" name="x_list" type="x_list" />
 *     <xs:element maxOccurs="unbounded" name="y_list" type="y_list" />
 *   </xs:sequence>
 * </xs:complexType>
*/
struct t_channels {
	t_channel channel;
	collapsed_vec<t_x_list, x_list_pool> x_lists;
	collapsed_vec<t_y_list, y_list_pool> y_lists;
};

/** Generated from:
 * <xs:complexType name="switches">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="switch" type="switch" />
 *   </xs:sequence>
 * </xs:complexType>
*/
struct t_switches {
	collapsed_vec<t_switch, switch_pool> switches;
};

/** Generated from:
 * <xs:complexType name="segments">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="segment" type="segment" />
 *   </xs:sequence>
 * </xs:complexType>
*/
struct t_segments {
	collapsed_vec<t_segment, segment_pool> segments;
};

/** Generated from:
 * <xs:complexType name="block_types">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="block_type" type="block_type" />
 *   </xs:sequence>
 * </xs:complexType>
*/
struct t_block_types {
	collapsed_vec<t_block_type, block_type_pool> block_types;
};

/** Generated from:
 * <xs:complexType name="grid_locs">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="grid_loc" type="grid_loc" />
 *   </xs:sequence>
 * </xs:complexType>
*/
struct t_grid_locs {
	collapsed_vec<t_grid_loc, grid_loc_pool> grid_locs;
};

/** Generated from:
 * <xs:complexType name="rr_nodes">
 *   <xs:choice maxOccurs="unbounded">
 *     <xs:element name="node" type="node" />
 *   </xs:choice>
 * </xs:complexType>
*/
struct t_rr_nodes {
	collapsed_vec<t_node, node_pool> nodes;
};

/** Generated from:
 * <xs:complexType name="rr_edges">
 *   <xs:choice maxOccurs="unbounded">
 *     <xs:element name="edge" type="edge" />
 *   </xs:choice>
 * </xs:complexType>
*/
struct t_rr_edges {
	collapsed_vec<t_edge, edge_pool> edges;
};

/** Generated from:
 * <xs:complexType name="bin_nodes">
 *   <xs:attribute name="file" type="xs:string" />
 * </xs:complexType>
*/
struct t_bin_nodes {
	const char * file;
};

/** Generated from:
 * <xs:complexType name="connection_box">
 *   <xs:attribute name="id" type="xs:unsignedInt" use="required" />
 *   <xs:attribute name="name" type="xs:string" use="required" />
 * </xs:complexType>
*/
struct t_connection_box {
	unsigned int id;
	const char * name;
};

/** Generated from:
 * <xs:complexType name="connection_boxes">
 *   <xs:sequence>
 *     <xs:element maxOccurs="unbounded" name="connection_box" type="connection_box" />
 *   </xs:sequence>
 *   <xs:attribute name="x_dim" type="xs:int" use="required" />
 *   <xs:attribute name="y_dim" type="xs:int" use="required" />
 *   <xs:attribute name="num_boxes" type="xs:unsignedInt" use="required" />
 * </xs:complexType>
*/
struct t_connection_boxes {
	unsigned int num_boxes;
	int x_dim;
	int y_dim;
	collapsed_vec<t_connection_box, connection_box_pool> connection_boxes;
};

/** Generated from:
 * <xs:complexType xmlns:xs="http://www.w3.org/2001/XMLSchema">
 *     <xs:all>
 *       <xs:element minOccurs="0" name="binary_nodes_and_edges" type="bin_nodes" />
 *       <xs:element minOccurs="0" name="connection_boxes" type="connection_boxes" />
 *       <xs:element name="channels" type="channels" />
 *       <xs:element name="switches" type="switches" />
 *       <xs:element name="segments" type="segments" />
 *       <xs:element name="block_types" type="block_types" />
 *       <xs:element name="grid" type="grid_locs" />
 *       <xs:element name="rr_nodes" type="rr_nodes" />
 *       <xs:element name="rr_edges" type="rr_edges" />
 *     </xs:all>
 *     <xs:attribute name="tool_name" type="xs:string" />
 *     <xs:attribute name="tool_version" type="xs:string" />
 *     <xs:attribute name="tool_comment" type="xs:string" />
 *   </xs:complexType>
*/
struct t_rr_graph {
	const char * tool_comment;
	const char * tool_name;
	const char * tool_version;
	bool has_binary_nodes_and_edges;
	t_bin_nodes binary_nodes_and_edges;
	bool has_connection_boxes;
	t_connection_boxes connection_boxes;
	t_channels channels;
	t_switches switches;
	t_segments segments;
	t_block_types block_types;
	t_grid_locs grid;
	t_rr_nodes rr_nodes;
	t_rr_edges rr_edges;
};

/* Classes generated from root elements. */
/** Generated from:
 * <xs:element name="rr_graph">
 *   <xs:complexType>
 *     <xs:all>
 *       <xs:element minOccurs="0" name="binary_nodes_and_edges" type="bin_nodes" />
 *       <xs:element minOccurs="0" name="connection_boxes" type="connection_boxes" />
 *       <xs:element name="channels" type="channels" />
 *       <xs:element name="switches" type="switches" />
 *       <xs:element name="segments" type="segments" />
 *       <xs:element name="block_types" type="block_types" />
 *       <xs:element name="grid" type="grid_locs" />
 *       <xs:element name="rr_nodes" type="rr_nodes" />
 *       <xs:element name="rr_edges" type="rr_edges" />
 *     </xs:all>
 *     <xs:attribute name="tool_name" type="xs:string" />
 *     <xs:attribute name="tool_version" type="xs:string" />
 *     <xs:attribute name="tool_comment" type="xs:string" />
 *   </xs:complexType>
 * </xs:element>
*/
class rr_graph : public t_rr_graph {
public:
	pugi::xml_parse_result load(std::istream &is);
	void write(std::ostream &os);
};

} /* namespace uxsd */
