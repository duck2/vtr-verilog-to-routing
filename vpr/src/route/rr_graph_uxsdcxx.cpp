/*
 * This file is generated by uxsdcxx 0.0.4.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: uxsdcxx.py rr_graph.xsd
 * Input file: /home/duck2/uxsdcxx/rr_graph.xsd
 * md5sum of input file: 86ad1829ffcbd56309275e329a54a96f
 */
#include "rr_graph_uxsdcxx.h"

/* All uxsdcxx functions and structs live in this namespace. */
namespace uxsd {

typedef const uint32_t __attribute__((aligned(1))) triehash_uu32;
typedef const uint64_t __attribute__((aligned(1))) triehash_uu64;
static_assert(alignof(triehash_uu32) == 1, "Unaligned 32-bit access not found.");
static_assert(alignof(triehash_uu64) == 1, "Unaligned 64-bit access not found.");
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define onechar(c, s, l) (((uint64_t)(c)) << (s))
#else
#define onechar(c, s, l) (((uint64_t)(c)) << (l-8-s))
#endif

/* Declarations for internal load functions for the root elements. */
void load_channel(const pugi::xml_node &root, t_channel *out);
void load_x_list(const pugi::xml_node &root, t_x_list *out);
void load_y_list(const pugi::xml_node &root, t_y_list *out);
void load_timing(const pugi::xml_node &root, t_timing *out);
void load_sizing(const pugi::xml_node &root, t_sizing *out);
void load_switch(const pugi::xml_node &root, t_switch *out);
void load_segment_timing(const pugi::xml_node &root, t_segment_timing *out);
void load_segment(const pugi::xml_node &root, t_segment *out);
void load_pin(const pugi::xml_node &root, t_pin *out);
void load_pin_class(const pugi::xml_node &root, t_pin_class *out);
void load_meta(const pugi::xml_node &root, t_meta *out);
void load_metadata(const pugi::xml_node &root, t_metadata *out);
void load_block_type(const pugi::xml_node &root, t_block_type *out);
void load_grid_loc(const pugi::xml_node &root, t_grid_loc *out);
void load_node_loc(const pugi::xml_node &root, t_node_loc *out);
void load_node_timing(const pugi::xml_node &root, t_node_timing *out);
void load_node_segment(const pugi::xml_node &root, t_node_segment *out);
void load_node_connection_box(const pugi::xml_node &root, t_node_connection_box *out);
void load_node_canonical_loc(const pugi::xml_node &root, t_node_canonical_loc *out);
void load_node(const pugi::xml_node &root, t_node *out);
void load_edge(const pugi::xml_node &root, t_edge *out);
void load_channels(const pugi::xml_node &root, t_channels *out);
void load_switches(const pugi::xml_node &root, t_switches *out);
void load_segments(const pugi::xml_node &root, t_segments *out);
void load_block_types(const pugi::xml_node &root, t_block_types *out);
void load_grid_locs(const pugi::xml_node &root, t_grid_locs *out);
void load_rr_nodes(const pugi::xml_node &root, t_rr_nodes *out);
void load_rr_edges(const pugi::xml_node &root, t_rr_edges *out);
void load_bin_nodes(const pugi::xml_node &root, t_bin_nodes *out);
void load_connection_box(const pugi::xml_node &root, t_connection_box *out);
void load_connection_boxes(const pugi::xml_node &root, t_connection_boxes *out);
void load_rr_graph(const pugi::xml_node &root, t_rr_graph *out);
std::vector<t_pin> pin_pool;
std::vector<t_meta> meta_pool;
std::vector<t_pin_class> pin_class_pool;
std::vector<t_x_list> x_list_pool;
std::vector<t_y_list> y_list_pool;
std::vector<t_switch> switch_pool;
std::vector<t_segment> segment_pool;
std::vector<t_block_type> block_type_pool;
std::vector<t_grid_loc> grid_loc_pool;
std::vector<t_node> node_pool;
std::vector<t_edge> edge_pool;
std::vector<t_connection_box> connection_box_pool;
char_pool_impl char_pool;

void clear_pools(void){
	pin_pool.clear();
	meta_pool.clear();
	pin_class_pool.clear();
	x_list_pool.clear();
	y_list_pool.clear();
	switch_pool.clear();
	segment_pool.clear();
	block_type_pool.clear();
	grid_loc_pool.clear();
	node_pool.clear();
	edge_pool.clear();
	connection_box_pool.clear();
}
void clear_strings(void){
	char_pool.clear();
}

/* Lookup tables for enums. */
const char *lookup_switch_type[] = {"UXSD_INVALID", "mux", "tristate", "pass_gate", "short", "buffer"};
const char *lookup_pin_type[] = {"UXSD_INVALID", "OPEN", "OUTPUT", "INPUT"};
const char *lookup_loc_side[] = {"UXSD_INVALID", "LEFT", "RIGHT", "TOP", "BOTTOM"};
const char *lookup_node_type[] = {"UXSD_INVALID", "CHANX", "CHANY", "SOURCE", "SINK", "OPIN", "IPIN"};
const char *lookup_node_direction[] = {"UXSD_INVALID", "INC_DIR", "DEC_DIR", "BI_DIR"};

/* Lexers(string->token functions) for enums. */
inline enum_switch_type lex_enum_switch_type(const char *in, bool throw_on_invalid){
	unsigned int len = strlen(in);
	switch(len){
	case 3:
		switch(in[0]){
		case onechar('m', 0, 8):
			switch(in[1]){
			case onechar('u', 0, 8):
				switch(in[2]){
				case onechar('x', 0, 8):
					return enum_switch_type::MUX;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('s', 0, 32) | onechar('h', 8, 32) | onechar('o', 16, 32) | onechar('r', 24, 32):
			switch(in[4]){
			case onechar('t', 0, 8):
				return enum_switch_type::SHORT;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('b', 0, 32) | onechar('u', 8, 32) | onechar('f', 16, 32) | onechar('f', 24, 32):
			switch(in[4]){
			case onechar('e', 0, 8):
				switch(in[5]){
				case onechar('r', 0, 8):
					return enum_switch_type::BUFFER;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('t', 0, 64) | onechar('r', 8, 64) | onechar('i', 16, 64) | onechar('s', 24, 64) | onechar('t', 32, 64) | onechar('a', 40, 64) | onechar('t', 48, 64) | onechar('e', 56, 64):
			return enum_switch_type::TRISTATE;
		break;
		default: break;
		}
		break;
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('p', 0, 64) | onechar('a', 8, 64) | onechar('s', 16, 64) | onechar('s', 24, 64) | onechar('_', 32, 64) | onechar('g', 40, 64) | onechar('a', 48, 64) | onechar('t', 56, 64):
			switch(in[8]){
			case onechar('e', 0, 8):
				return enum_switch_type::PASS_GATE;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	if(throw_on_invalid)
		throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_switch_type.");
	return enum_switch_type::UXSD_INVALID;
}

inline enum_pin_type lex_enum_pin_type(const char *in, bool throw_on_invalid){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('O', 0, 32) | onechar('P', 8, 32) | onechar('E', 16, 32) | onechar('N', 24, 32):
			return enum_pin_type::OPEN;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('I', 0, 32) | onechar('N', 8, 32) | onechar('P', 16, 32) | onechar('U', 24, 32):
			switch(in[4]){
			case onechar('T', 0, 8):
				return enum_pin_type::INPUT;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('O', 0, 32) | onechar('U', 8, 32) | onechar('T', 16, 32) | onechar('P', 24, 32):
			switch(in[4]){
			case onechar('U', 0, 8):
				switch(in[5]){
				case onechar('T', 0, 8):
					return enum_pin_type::OUTPUT;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	if(throw_on_invalid)
		throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_pin_type.");
	return enum_pin_type::UXSD_INVALID;
}

inline enum_loc_side lex_enum_loc_side(const char *in, bool throw_on_invalid){
	unsigned int len = strlen(in);
	switch(len){
	case 3:
		switch(in[0]){
		case onechar('T', 0, 8):
			switch(in[1]){
			case onechar('O', 0, 8):
				switch(in[2]){
				case onechar('P', 0, 8):
					return enum_loc_side::TOP;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('L', 0, 32) | onechar('E', 8, 32) | onechar('F', 16, 32) | onechar('T', 24, 32):
			return enum_loc_side::LEFT;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('R', 0, 32) | onechar('I', 8, 32) | onechar('G', 16, 32) | onechar('H', 24, 32):
			switch(in[4]){
			case onechar('T', 0, 8):
				return enum_loc_side::RIGHT;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('B', 0, 32) | onechar('O', 8, 32) | onechar('T', 16, 32) | onechar('T', 24, 32):
			switch(in[4]){
			case onechar('O', 0, 8):
				switch(in[5]){
				case onechar('M', 0, 8):
					return enum_loc_side::BOTTOM;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	if(throw_on_invalid)
		throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_loc_side.");
	return enum_loc_side::UXSD_INVALID;
}

inline enum_node_type lex_enum_node_type(const char *in, bool throw_on_invalid){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('I', 0, 32) | onechar('P', 8, 32) | onechar('I', 16, 32) | onechar('N', 24, 32):
			return enum_node_type::IPIN;
		break;
		case onechar('O', 0, 32) | onechar('P', 8, 32) | onechar('I', 16, 32) | onechar('N', 24, 32):
			return enum_node_type::OPIN;
		break;
		case onechar('S', 0, 32) | onechar('I', 8, 32) | onechar('N', 16, 32) | onechar('K', 24, 32):
			return enum_node_type::SINK;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('C', 0, 32) | onechar('H', 8, 32) | onechar('A', 16, 32) | onechar('N', 24, 32):
			switch(in[4]){
			case onechar('X', 0, 8):
				return enum_node_type::CHANX;
			break;
			case onechar('Y', 0, 8):
				return enum_node_type::CHANY;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('S', 0, 32) | onechar('O', 8, 32) | onechar('U', 16, 32) | onechar('R', 24, 32):
			switch(in[4]){
			case onechar('C', 0, 8):
				switch(in[5]){
				case onechar('E', 0, 8):
					return enum_node_type::SOURCE;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	if(throw_on_invalid)
		throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_node_type.");
	return enum_node_type::UXSD_INVALID;
}

inline enum_node_direction lex_enum_node_direction(const char *in, bool throw_on_invalid){
	unsigned int len = strlen(in);
	switch(len){
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('B', 0, 32) | onechar('I', 8, 32) | onechar('_', 16, 32) | onechar('D', 24, 32):
			switch(in[4]){
			case onechar('I', 0, 8):
				switch(in[5]){
				case onechar('R', 0, 8):
					return enum_node_direction::BI_DIR;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 7:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('D', 0, 32) | onechar('E', 8, 32) | onechar('C', 16, 32) | onechar('_', 24, 32):
			switch(in[4]){
			case onechar('D', 0, 8):
				switch(in[5]){
				case onechar('I', 0, 8):
					switch(in[6]){
					case onechar('R', 0, 8):
						return enum_node_direction::DEC_DIR;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		case onechar('I', 0, 32) | onechar('N', 8, 32) | onechar('C', 16, 32) | onechar('_', 24, 32):
			switch(in[4]){
			case onechar('D', 0, 8):
				switch(in[5]){
				case onechar('I', 0, 8):
					switch(in[6]){
					case onechar('R', 0, 8):
						return enum_node_direction::INC_DIR;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	if(throw_on_invalid)
		throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_node_direction.");
	return enum_node_direction::UXSD_INVALID;
}


/* Load functions for the root elements. */
pugi::xml_parse_result rr_graph::load(std::istream &is){
	pugi::xml_document doc;
	pugi::xml_parse_result result = doc.load(is);
	if(!result) return result;
	for(pugi::xml_node node= doc.first_child(); node; node = node.next_sibling()){
		if(std::strcmp(node.name(), "rr_graph") == 0){
			/* If errno is set up to this point, it messes with strtol errno checking. */
			errno = 0;
			load_rr_graph(node, this);
		}
		else throw std::runtime_error("Invalid root-level element " + std::string(node.name()));
	}
	return result;
}


/* Write functions for the root elements. */
void rr_graph::write(std::ostream &os){
	os << "<rr_graph";
	if((bool)(*this).tool_comment)
		os << " tool_comment=\"" << (*this).tool_comment << "\"";
	if((bool)(*this).tool_name)
		os << " tool_name=\"" << (*this).tool_name << "\"";
	if((bool)(*this).tool_version)
		os << " tool_version=\"" << (*this).tool_version << "\"";
	os << ">";
	if((*this).has_binary_nodes_and_edges){
		os << "<binary_nodes_and_edges";
		if((bool)(*this).binary_nodes_and_edges.file)
			os << " file=\"" << (*this).binary_nodes_and_edges.file << "\"";
		os << "/>";
	}
	if((*this).has_connection_boxes){
		os << "<connection_boxes";
		os << " num_boxes=\"" << (*this).connection_boxes.num_boxes << "\"";
		os << " x_dim=\"" << (*this).connection_boxes.x_dim << "\"";
		os << " y_dim=\"" << (*this).connection_boxes.y_dim << "\"";
		os << ">";
		for(auto &connection_box: (*this).connection_boxes.connection_boxes){
			os << "<connection_box";
			os << " id=\"" << connection_box.id << "\"";
			os << " name=\"" << connection_box.name << "\"";
			os << "/>";
		}
		os << "</connection_boxes>";
	}
	os << "<channels";
	os << ">";
	os << "<channel";
	os << " chan_width_max=\"" << (*this).channels.channel.chan_width_max << "\"";
	os << " x_max=\"" << (*this).channels.channel.x_max << "\"";
	os << " x_min=\"" << (*this).channels.channel.x_min << "\"";
	os << " y_max=\"" << (*this).channels.channel.y_max << "\"";
	os << " y_min=\"" << (*this).channels.channel.y_min << "\"";
	os << "/>";
	for(auto &x_list: (*this).channels.x_lists){
		os << "<x_list";
		os << " index=\"" << x_list.index << "\"";
		os << " info=\"" << x_list.info << "\"";
		os << "/>";
	}
	for(auto &y_list: (*this).channels.y_lists){
		os << "<y_list";
		os << " index=\"" << y_list.index << "\"";
		os << " info=\"" << y_list.info << "\"";
		os << "/>";
	}
	os << "</channels>";
	os << "<switches";
	os << ">";
	for(auto &switch_: (*this).switches.switches){
		os << "<switch";
		os << " id=\"" << switch_.id << "\"";
		os << " name=\"" << switch_.name << "\"";
		if((bool)switch_.type)
			os << " type=\"" << lookup_switch_type[(int)switch_.type] << "\"";
		os << ">";
		if(switch_.has_timing){
			os << "<timing";
			os << " Cin=\"" << switch_.timing.Cin << "\"";
			os << " Cinternal=\"" << switch_.timing.Cinternal << "\"";
			os << " Cout=\"" << switch_.timing.Cout << "\"";
			os << " R=\"" << switch_.timing.R << "\"";
			os << " Tdel=\"" << switch_.timing.Tdel << "\"";
			os << "/>";
		}
		os << "<sizing";
		os << " buf_size=\"" << switch_.sizing.buf_size << "\"";
		os << " mux_trans_size=\"" << switch_.sizing.mux_trans_size << "\"";
		os << "/>";
		os << "</switch>";
	}
	os << "</switches>";
	os << "<segments";
	os << ">";
	for(auto &segment: (*this).segments.segments){
		os << "<segment";
		os << " id=\"" << segment.id << "\"";
		os << " name=\"" << segment.name << "\"";
		os << ">";
		if(segment.has_timing){
			os << "<timing";
			if((bool)segment.timing.C_per_meter)
				os << " C_per_meter=\"" << segment.timing.C_per_meter << "\"";
			if((bool)segment.timing.R_per_meter)
				os << " R_per_meter=\"" << segment.timing.R_per_meter << "\"";
			os << "/>";
		}
		os << "</segment>";
	}
	os << "</segments>";
	os << "<block_types";
	os << ">";
	for(auto &block_type: (*this).block_types.block_types){
		os << "<block_type";
		os << " height=\"" << block_type.height << "\"";
		os << " id=\"" << block_type.id << "\"";
		os << " name=\"" << block_type.name << "\"";
		os << " width=\"" << block_type.width << "\"";
		os << ">";
		for(auto &pin_class: block_type.pin_classes){
			os << "<pin_class";
			os << " type=\"" << lookup_pin_type[(int)pin_class.type] << "\"";
			os << ">";
			for(auto &pin: pin_class.pins){
				os << "<pin";
				os << " ptc=\"" << pin.ptc << "\"";
				os << ">";
				os << pin.value;
				os << "</pin>";
			}
			os << "</pin_class>";
		}
		os << "</block_type>";
	}
	os << "</block_types>";
	os << "<grid";
	os << ">";
	for(auto &grid_loc: (*this).grid.grid_locs){
		os << "<grid_loc";
		os << " block_type_id=\"" << grid_loc.block_type_id << "\"";
		os << " height_offset=\"" << grid_loc.height_offset << "\"";
		os << " width_offset=\"" << grid_loc.width_offset << "\"";
		os << " x=\"" << grid_loc.x << "\"";
		os << " y=\"" << grid_loc.y << "\"";
		os << "/>";
	}
	os << "</grid>";
	os << "<rr_nodes";
	os << ">";
	for(auto &node: (*this).rr_nodes.nodes){
		os << "<node";
		os << " capacity=\"" << node.capacity << "\"";
		if((bool)node.direction)
			os << " direction=\"" << lookup_node_direction[(int)node.direction] << "\"";
		os << " id=\"" << node.id << "\"";
		os << " type=\"" << lookup_node_type[(int)node.type] << "\"";
		os << ">";
		os << "<loc";
		os << " ptc=\"" << node.loc.ptc << "\"";
		if((bool)node.loc.side)
			os << " side=\"" << lookup_loc_side[(int)node.loc.side] << "\"";
		os << " xhigh=\"" << node.loc.xhigh << "\"";
		os << " xlow=\"" << node.loc.xlow << "\"";
		os << " yhigh=\"" << node.loc.yhigh << "\"";
		os << " ylow=\"" << node.loc.ylow << "\"";
		os << "/>";
		if(node.has_timing){
			os << "<timing";
			os << " C=\"" << node.timing.C << "\"";
			os << " R=\"" << node.timing.R << "\"";
			os << "/>";
		}
		if(node.has_segment){
			os << "<segment";
			os << " segment_id=\"" << node.segment.segment_id << "\"";
			os << "/>";
		}
		if(node.has_connection_box){
			os << "<connection_box";
			os << " id=\"" << node.connection_box.id << "\"";
			os << " x=\"" << node.connection_box.x << "\"";
			os << " y=\"" << node.connection_box.y << "\"";
			os << "/>";
		}
		if(node.has_canonical_loc){
			os << "<canonical_loc";
			os << " x=\"" << node.canonical_loc.x << "\"";
			os << " y=\"" << node.canonical_loc.y << "\"";
			os << "/>";
		}
		if(node.has_metadata){
			os << "<metadata";
			os << ">";
			for(auto &meta: node.metadata.metas){
				os << "<meta";
				os << " name=\"" << meta.name << "\"";
				os << ">";
				os << meta.value;
				os << "</meta>";
			}
			os << "</metadata>";
		}
		os << "</node>";
	}
	os << "</rr_nodes>";
	os << "<rr_edges";
	os << ">";
	for(auto &edge: (*this).rr_edges.edges){
		os << "<edge";
		if((bool)edge.id)
			os << " id=\"" << edge.id << "\"";
		os << " sink_node=\"" << edge.sink_node << "\"";
		os << " src_node=\"" << edge.src_node << "\"";
		os << " switch_id=\"" << edge.switch_id << "\"";
		os << ">";
		if(edge.has_metadata){
			os << "<metadata";
			os << ">";
			for(auto &meta: edge.metadata.metas){
				os << "<meta";
				os << " name=\"" << meta.name << "\"";
				os << ">";
				os << meta.value;
				os << "</meta>";
			}
			os << "</metadata>";
		}
		os << "</edge>";
	}
	os << "</rr_edges>";
	os << "</rr_graph>";
}


/* Tokens for attribute and node names. */
enum class atok_t_channel {CHAN_WIDTH_MAX, X_MAX, X_MIN, Y_MAX, Y_MIN};
const char *atok_lookup_t_channel[] = {"chan_width_max", "x_max", "x_min", "y_max", "y_min"};

enum class atok_t_x_list {INDEX, INFO};
const char *atok_lookup_t_x_list[] = {"index", "info"};

enum class atok_t_y_list {INDEX, INFO};
const char *atok_lookup_t_y_list[] = {"index", "info"};

enum class atok_t_timing {CIN, CINTERNAL, COUT, R, TDEL};
const char *atok_lookup_t_timing[] = {"Cin", "Cinternal", "Cout", "R", "Tdel"};

enum class atok_t_sizing {BUF_SIZE, MUX_TRANS_SIZE};
const char *atok_lookup_t_sizing[] = {"buf_size", "mux_trans_size"};

enum class gtok_t_switch {TIMING, SIZING};
const char *gtok_lookup_t_switch[] = {"timing", "sizing"};enum class atok_t_switch {ID, NAME, TYPE};
const char *atok_lookup_t_switch[] = {"id", "name", "type"};

enum class atok_t_segment_timing {C_PER_METER, R_PER_METER};
const char *atok_lookup_t_segment_timing[] = {"C_per_meter", "R_per_meter"};

enum class gtok_t_segment {TIMING};
const char *gtok_lookup_t_segment[] = {"timing"};enum class atok_t_segment {ID, NAME};
const char *atok_lookup_t_segment[] = {"id", "name"};

enum class atok_t_pin {PTC};
const char *atok_lookup_t_pin[] = {"ptc"};

enum class gtok_t_pin_class {PIN};
const char *gtok_lookup_t_pin_class[] = {"pin"};enum class atok_t_pin_class {TYPE};
const char *atok_lookup_t_pin_class[] = {"type"};

enum class atok_t_meta {NAME};
const char *atok_lookup_t_meta[] = {"name"};

enum class gtok_t_metadata {META};
const char *gtok_lookup_t_metadata[] = {"meta"};
enum class gtok_t_block_type {PIN_CLASS};
const char *gtok_lookup_t_block_type[] = {"pin_class"};enum class atok_t_block_type {HEIGHT, ID, NAME, WIDTH};
const char *atok_lookup_t_block_type[] = {"height", "id", "name", "width"};

enum class atok_t_grid_loc {BLOCK_TYPE_ID, HEIGHT_OFFSET, WIDTH_OFFSET, X, Y};
const char *atok_lookup_t_grid_loc[] = {"block_type_id", "height_offset", "width_offset", "x", "y"};

enum class atok_t_node_loc {PTC, SIDE, XHIGH, XLOW, YHIGH, YLOW};
const char *atok_lookup_t_node_loc[] = {"ptc", "side", "xhigh", "xlow", "yhigh", "ylow"};

enum class atok_t_node_timing {C, R};
const char *atok_lookup_t_node_timing[] = {"C", "R"};

enum class atok_t_node_segment {SEGMENT_ID};
const char *atok_lookup_t_node_segment[] = {"segment_id"};

enum class atok_t_node_connection_box {ID, X, Y};
const char *atok_lookup_t_node_connection_box[] = {"id", "x", "y"};

enum class atok_t_node_canonical_loc {X, Y};
const char *atok_lookup_t_node_canonical_loc[] = {"x", "y"};

enum class gtok_t_node {LOC, TIMING, SEGMENT, CONNECTION_BOX, CANONICAL_LOC, METADATA};
const char *gtok_lookup_t_node[] = {"loc", "timing", "segment", "connection_box", "canonical_loc", "metadata"};enum class atok_t_node {CAPACITY, DIRECTION, ID, TYPE};
const char *atok_lookup_t_node[] = {"capacity", "direction", "id", "type"};

enum class gtok_t_edge {METADATA};
const char *gtok_lookup_t_edge[] = {"metadata"};enum class atok_t_edge {ID, SINK_NODE, SRC_NODE, SWITCH_ID};
const char *atok_lookup_t_edge[] = {"id", "sink_node", "src_node", "switch_id"};

enum class gtok_t_channels {CHANNEL, X_LIST, Y_LIST};
const char *gtok_lookup_t_channels[] = {"channel", "x_list", "y_list"};
enum class gtok_t_switches {SWITCH};
const char *gtok_lookup_t_switches[] = {"switch"};
enum class gtok_t_segments {SEGMENT};
const char *gtok_lookup_t_segments[] = {"segment"};
enum class gtok_t_block_types {BLOCK_TYPE};
const char *gtok_lookup_t_block_types[] = {"block_type"};
enum class gtok_t_grid_locs {GRID_LOC};
const char *gtok_lookup_t_grid_locs[] = {"grid_loc"};
enum class gtok_t_rr_nodes {NODE};
const char *gtok_lookup_t_rr_nodes[] = {"node"};
enum class gtok_t_rr_edges {EDGE};
const char *gtok_lookup_t_rr_edges[] = {"edge"};
enum class atok_t_bin_nodes {FILE};
const char *atok_lookup_t_bin_nodes[] = {"file"};

enum class atok_t_connection_box {ID, NAME};
const char *atok_lookup_t_connection_box[] = {"id", "name"};

enum class gtok_t_connection_boxes {CONNECTION_BOX};
const char *gtok_lookup_t_connection_boxes[] = {"connection_box"};enum class atok_t_connection_boxes {NUM_BOXES, X_DIM, Y_DIM};
const char *atok_lookup_t_connection_boxes[] = {"num_boxes", "x_dim", "y_dim"};

enum class gtok_t_rr_graph {BINARY_NODES_AND_EDGES, CONNECTION_BOXES, CHANNELS, SWITCHES, SEGMENTS, BLOCK_TYPES, GRID, RR_NODES, RR_EDGES};
const char *gtok_lookup_t_rr_graph[] = {"binary_nodes_and_edges", "connection_boxes", "channels", "switches", "segments", "block_types", "grid", "rr_nodes", "rr_edges"};enum class atok_t_rr_graph {TOOL_COMMENT, TOOL_NAME, TOOL_VERSION};
const char *atok_lookup_t_rr_graph[] = {"tool_comment", "tool_name", "tool_version"};


/* Internal lexers. These convert the PugiXML node names to input tokens. */
inline atok_t_channel lex_attr_t_channel(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('a', 24, 32):
			switch(in[4]){
			case onechar('x', 0, 8):
				return atok_t_channel::X_MAX;
			break;
			default: break;
			}
		break;
		case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				return atok_t_channel::X_MIN;
			break;
			default: break;
			}
		break;
		case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('a', 24, 32):
			switch(in[4]){
			case onechar('x', 0, 8):
				return atok_t_channel::Y_MAX;
			break;
			default: break;
			}
		break;
		case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				return atok_t_channel::Y_MIN;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 14:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('h', 8, 64) | onechar('a', 16, 64) | onechar('n', 24, 64) | onechar('_', 32, 64) | onechar('w', 40, 64) | onechar('i', 48, 64) | onechar('d', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('t', 0, 32) | onechar('h', 8, 32) | onechar('_', 16, 32) | onechar('m', 24, 32):
				switch(in[12]){
				case onechar('a', 0, 8):
					switch(in[13]){
					case onechar('x', 0, 8):
						return atok_t_channel::CHAN_WIDTH_MAX;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <channel>.");
}

inline atok_t_x_list lex_attr_t_x_list(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('f', 16, 32) | onechar('o', 24, 32):
			return atok_t_x_list::INFO;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
			switch(in[4]){
			case onechar('x', 0, 8):
				return atok_t_x_list::INDEX;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <x_list>.");
}

inline atok_t_y_list lex_attr_t_y_list(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('f', 16, 32) | onechar('o', 24, 32):
			return atok_t_y_list::INFO;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
			switch(in[4]){
			case onechar('x', 0, 8):
				return atok_t_y_list::INDEX;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <y_list>.");
}

inline atok_t_timing lex_attr_t_timing(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('R', 0, 8):
			return atok_t_timing::R;
		break;
		default: break;
		}
		break;
	case 3:
		switch(in[0]){
		case onechar('C', 0, 8):
			switch(in[1]){
			case onechar('i', 0, 8):
				switch(in[2]){
				case onechar('n', 0, 8):
					return atok_t_timing::CIN;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('C', 0, 32) | onechar('o', 8, 32) | onechar('u', 16, 32) | onechar('t', 24, 32):
			return atok_t_timing::COUT;
		break;
		case onechar('T', 0, 32) | onechar('d', 8, 32) | onechar('e', 16, 32) | onechar('l', 24, 32):
			return atok_t_timing::TDEL;
		break;
		default: break;
		}
		break;
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('C', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('t', 24, 64) | onechar('e', 32, 64) | onechar('r', 40, 64) | onechar('n', 48, 64) | onechar('a', 56, 64):
			switch(in[8]){
			case onechar('l', 0, 8):
				return atok_t_timing::CINTERNAL;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <timing>.");
}

inline atok_t_sizing lex_attr_t_sizing(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('b', 0, 64) | onechar('u', 8, 64) | onechar('f', 16, 64) | onechar('_', 24, 64) | onechar('s', 32, 64) | onechar('i', 40, 64) | onechar('z', 48, 64) | onechar('e', 56, 64):
			return atok_t_sizing::BUF_SIZE;
		break;
		default: break;
		}
		break;
	case 14:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('m', 0, 64) | onechar('u', 8, 64) | onechar('x', 16, 64) | onechar('_', 24, 64) | onechar('t', 32, 64) | onechar('r', 40, 64) | onechar('a', 48, 64) | onechar('n', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('s', 0, 32) | onechar('_', 8, 32) | onechar('s', 16, 32) | onechar('i', 24, 32):
				switch(in[12]){
				case onechar('z', 0, 8):
					switch(in[13]){
					case onechar('e', 0, 8):
						return atok_t_sizing::MUX_TRANS_SIZE;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <sizing>.");
}

inline gtok_t_switch lex_node_t_switch(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('s', 0, 32) | onechar('i', 8, 32) | onechar('z', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				switch(in[5]){
				case onechar('g', 0, 8):
					return gtok_t_switch::SIZING;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		case onechar('t', 0, 32) | onechar('i', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				switch(in[5]){
				case onechar('g', 0, 8):
					return gtok_t_switch::TIMING;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <switch>.");
}
inline atok_t_switch lex_attr_t_switch(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_switch::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
			return atok_t_switch::NAME;
		break;
		case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
			return atok_t_switch::TYPE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <switch>.");
}

inline atok_t_segment_timing lex_attr_t_segment_timing(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 11:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('C', 0, 64) | onechar('_', 8, 64) | onechar('p', 16, 64) | onechar('e', 24, 64) | onechar('r', 32, 64) | onechar('_', 40, 64) | onechar('m', 48, 64) | onechar('e', 56, 64):
			switch(in[8]){
			case onechar('t', 0, 8):
				switch(in[9]){
				case onechar('e', 0, 8):
					switch(in[10]){
					case onechar('r', 0, 8):
						return atok_t_segment_timing::C_PER_METER;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		case onechar('R', 0, 64) | onechar('_', 8, 64) | onechar('p', 16, 64) | onechar('e', 24, 64) | onechar('r', 32, 64) | onechar('_', 40, 64) | onechar('m', 48, 64) | onechar('e', 56, 64):
			switch(in[8]){
			case onechar('t', 0, 8):
				switch(in[9]){
				case onechar('e', 0, 8):
					switch(in[10]){
					case onechar('r', 0, 8):
						return atok_t_segment_timing::R_PER_METER;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <segment_timing>.");
}

inline gtok_t_segment lex_node_t_segment(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('t', 0, 32) | onechar('i', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				switch(in[5]){
				case onechar('g', 0, 8):
					return gtok_t_segment::TIMING;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <segment>.");
}
inline atok_t_segment lex_attr_t_segment(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_segment::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
			return atok_t_segment::NAME;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <segment>.");
}

inline atok_t_pin lex_attr_t_pin(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 3:
		switch(in[0]){
		case onechar('p', 0, 8):
			switch(in[1]){
			case onechar('t', 0, 8):
				switch(in[2]){
				case onechar('c', 0, 8):
					return atok_t_pin::PTC;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <pin>.");
}

inline gtok_t_pin_class lex_node_t_pin_class(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 3:
		switch(in[0]){
		case onechar('p', 0, 8):
			switch(in[1]){
			case onechar('i', 0, 8):
				switch(in[2]){
				case onechar('n', 0, 8):
					return gtok_t_pin_class::PIN;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <pin_class>.");
}
inline atok_t_pin_class lex_attr_t_pin_class(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
			return atok_t_pin_class::TYPE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <pin_class>.");
}

inline atok_t_meta lex_attr_t_meta(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
			return atok_t_meta::NAME;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <meta>.");
}

inline gtok_t_metadata lex_node_t_metadata(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('m', 0, 32) | onechar('e', 8, 32) | onechar('t', 16, 32) | onechar('a', 24, 32):
			return gtok_t_metadata::META;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <metadata>.");
}

inline gtok_t_block_type lex_node_t_block_type(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('p', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('_', 24, 64) | onechar('c', 32, 64) | onechar('l', 40, 64) | onechar('a', 48, 64) | onechar('s', 56, 64):
			switch(in[8]){
			case onechar('s', 0, 8):
				return gtok_t_block_type::PIN_CLASS;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <block_type>.");
}
inline atok_t_block_type lex_attr_t_block_type(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_block_type::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
			return atok_t_block_type::NAME;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('w', 0, 32) | onechar('i', 8, 32) | onechar('d', 16, 32) | onechar('t', 24, 32):
			switch(in[4]){
			case onechar('h', 0, 8):
				return atok_t_block_type::WIDTH;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('h', 0, 32) | onechar('e', 8, 32) | onechar('i', 16, 32) | onechar('g', 24, 32):
			switch(in[4]){
			case onechar('h', 0, 8):
				switch(in[5]){
				case onechar('t', 0, 8):
					return atok_t_block_type::HEIGHT;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <block_type>.");
}

inline atok_t_grid_loc lex_attr_t_grid_loc(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('x', 0, 8):
			return atok_t_grid_loc::X;
		break;
		case onechar('y', 0, 8):
			return atok_t_grid_loc::Y;
		break;
		default: break;
		}
		break;
	case 12:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('w', 0, 64) | onechar('i', 8, 64) | onechar('d', 16, 64) | onechar('t', 24, 64) | onechar('h', 32, 64) | onechar('_', 40, 64) | onechar('o', 48, 64) | onechar('f', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('f', 0, 32) | onechar('s', 8, 32) | onechar('e', 16, 32) | onechar('t', 24, 32):
				return atok_t_grid_loc::WIDTH_OFFSET;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 13:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('b', 0, 64) | onechar('l', 8, 64) | onechar('o', 16, 64) | onechar('c', 24, 64) | onechar('k', 32, 64) | onechar('_', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('p', 0, 32) | onechar('e', 8, 32) | onechar('_', 16, 32) | onechar('i', 24, 32):
				switch(in[12]){
				case onechar('d', 0, 8):
					return atok_t_grid_loc::BLOCK_TYPE_ID;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		case onechar('h', 0, 64) | onechar('e', 8, 64) | onechar('i', 16, 64) | onechar('g', 24, 64) | onechar('h', 32, 64) | onechar('t', 40, 64) | onechar('_', 48, 64) | onechar('o', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('f', 0, 32) | onechar('f', 8, 32) | onechar('s', 16, 32) | onechar('e', 24, 32):
				switch(in[12]){
				case onechar('t', 0, 8):
					return atok_t_grid_loc::HEIGHT_OFFSET;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <grid_loc>.");
}

inline atok_t_node_loc lex_attr_t_node_loc(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 3:
		switch(in[0]){
		case onechar('p', 0, 8):
			switch(in[1]){
			case onechar('t', 0, 8):
				switch(in[2]){
				case onechar('c', 0, 8):
					return atok_t_node_loc::PTC;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('s', 0, 32) | onechar('i', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
			return atok_t_node_loc::SIDE;
		break;
		case onechar('x', 0, 32) | onechar('l', 8, 32) | onechar('o', 16, 32) | onechar('w', 24, 32):
			return atok_t_node_loc::XLOW;
		break;
		case onechar('y', 0, 32) | onechar('l', 8, 32) | onechar('o', 16, 32) | onechar('w', 24, 32):
			return atok_t_node_loc::YLOW;
		break;
		default: break;
		}
		break;
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('x', 0, 32) | onechar('h', 8, 32) | onechar('i', 16, 32) | onechar('g', 24, 32):
			switch(in[4]){
			case onechar('h', 0, 8):
				return atok_t_node_loc::XHIGH;
			break;
			default: break;
			}
		break;
		case onechar('y', 0, 32) | onechar('h', 8, 32) | onechar('i', 16, 32) | onechar('g', 24, 32):
			switch(in[4]){
			case onechar('h', 0, 8):
				return atok_t_node_loc::YHIGH;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_loc>.");
}

inline atok_t_node_timing lex_attr_t_node_timing(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('C', 0, 8):
			return atok_t_node_timing::C;
		break;
		case onechar('R', 0, 8):
			return atok_t_node_timing::R;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_timing>.");
}

inline atok_t_node_segment lex_attr_t_node_segment(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 10:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('s', 0, 64) | onechar('e', 8, 64) | onechar('g', 16, 64) | onechar('m', 24, 64) | onechar('e', 32, 64) | onechar('n', 40, 64) | onechar('t', 48, 64) | onechar('_', 56, 64):
			switch(in[8]){
			case onechar('i', 0, 8):
				switch(in[9]){
				case onechar('d', 0, 8):
					return atok_t_node_segment::SEGMENT_ID;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_segment>.");
}

inline atok_t_node_connection_box lex_attr_t_node_connection_box(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('x', 0, 8):
			return atok_t_node_connection_box::X;
		break;
		case onechar('y', 0, 8):
			return atok_t_node_connection_box::Y;
		break;
		default: break;
		}
		break;
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_node_connection_box::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_connection_box>.");
}

inline atok_t_node_canonical_loc lex_attr_t_node_canonical_loc(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('x', 0, 8):
			return atok_t_node_canonical_loc::X;
		break;
		case onechar('y', 0, 8):
			return atok_t_node_canonical_loc::Y;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_canonical_loc>.");
}

inline gtok_t_node lex_node_t_node(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 3:
		switch(in[0]){
		case onechar('l', 0, 8):
			switch(in[1]){
			case onechar('o', 0, 8):
				switch(in[2]){
				case onechar('c', 0, 8):
					return gtok_t_node::LOC;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('t', 0, 32) | onechar('i', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				switch(in[5]){
				case onechar('g', 0, 8):
					return gtok_t_node::TIMING;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 7:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('s', 0, 32) | onechar('e', 8, 32) | onechar('g', 16, 32) | onechar('m', 24, 32):
			switch(in[4]){
			case onechar('e', 0, 8):
				switch(in[5]){
				case onechar('n', 0, 8):
					switch(in[6]){
					case onechar('t', 0, 8):
						return gtok_t_node::SEGMENT;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('m', 0, 64) | onechar('e', 8, 64) | onechar('t', 16, 64) | onechar('a', 24, 64) | onechar('d', 32, 64) | onechar('a', 40, 64) | onechar('t', 48, 64) | onechar('a', 56, 64):
			return gtok_t_node::METADATA;
		break;
		default: break;
		}
		break;
	case 13:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('a', 8, 64) | onechar('n', 16, 64) | onechar('o', 24, 64) | onechar('n', 32, 64) | onechar('i', 40, 64) | onechar('c', 48, 64) | onechar('a', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('l', 0, 32) | onechar('_', 8, 32) | onechar('l', 16, 32) | onechar('o', 24, 32):
				switch(in[12]){
				case onechar('c', 0, 8):
					return gtok_t_node::CANONICAL_LOC;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 14:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('o', 8, 64) | onechar('n', 16, 64) | onechar('n', 24, 64) | onechar('e', 32, 64) | onechar('c', 40, 64) | onechar('t', 48, 64) | onechar('i', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('o', 0, 32) | onechar('n', 8, 32) | onechar('_', 16, 32) | onechar('b', 24, 32):
				switch(in[12]){
				case onechar('o', 0, 8):
					switch(in[13]){
					case onechar('x', 0, 8):
						return gtok_t_node::CONNECTION_BOX;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <node>.");
}
inline atok_t_node lex_attr_t_node(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_node::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
			return atok_t_node::TYPE;
		break;
		default: break;
		}
		break;
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('a', 8, 64) | onechar('p', 16, 64) | onechar('a', 24, 64) | onechar('c', 32, 64) | onechar('i', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
			return atok_t_node::CAPACITY;
		break;
		default: break;
		}
		break;
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('d', 0, 64) | onechar('i', 8, 64) | onechar('r', 16, 64) | onechar('e', 24, 64) | onechar('c', 32, 64) | onechar('t', 40, 64) | onechar('i', 48, 64) | onechar('o', 56, 64):
			switch(in[8]){
			case onechar('n', 0, 8):
				return atok_t_node::DIRECTION;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node>.");
}

inline gtok_t_edge lex_node_t_edge(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('m', 0, 64) | onechar('e', 8, 64) | onechar('t', 16, 64) | onechar('a', 24, 64) | onechar('d', 32, 64) | onechar('a', 40, 64) | onechar('t', 48, 64) | onechar('a', 56, 64):
			return gtok_t_edge::METADATA;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <edge>.");
}
inline atok_t_edge lex_attr_t_edge(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_edge::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('s', 0, 64) | onechar('r', 8, 64) | onechar('c', 16, 64) | onechar('_', 24, 64) | onechar('n', 32, 64) | onechar('o', 40, 64) | onechar('d', 48, 64) | onechar('e', 56, 64):
			return atok_t_edge::SRC_NODE;
		break;
		default: break;
		}
		break;
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('s', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('k', 24, 64) | onechar('_', 32, 64) | onechar('n', 40, 64) | onechar('o', 48, 64) | onechar('d', 56, 64):
			switch(in[8]){
			case onechar('e', 0, 8):
				return atok_t_edge::SINK_NODE;
			break;
			default: break;
			}
		break;
		case onechar('s', 0, 64) | onechar('w', 8, 64) | onechar('i', 16, 64) | onechar('t', 24, 64) | onechar('c', 32, 64) | onechar('h', 40, 64) | onechar('_', 48, 64) | onechar('i', 56, 64):
			switch(in[8]){
			case onechar('d', 0, 8):
				return atok_t_edge::SWITCH_ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <edge>.");
}

inline gtok_t_channels lex_node_t_channels(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('l', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('s', 0, 8):
				switch(in[5]){
				case onechar('t', 0, 8):
					return gtok_t_channels::X_LIST;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('l', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('s', 0, 8):
				switch(in[5]){
				case onechar('t', 0, 8):
					return gtok_t_channels::Y_LIST;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 7:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('c', 0, 32) | onechar('h', 8, 32) | onechar('a', 16, 32) | onechar('n', 24, 32):
			switch(in[4]){
			case onechar('n', 0, 8):
				switch(in[5]){
				case onechar('e', 0, 8):
					switch(in[6]){
					case onechar('l', 0, 8):
						return gtok_t_channels::CHANNEL;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <channels>.");
}

inline gtok_t_switches lex_node_t_switches(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 6:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('s', 0, 32) | onechar('w', 8, 32) | onechar('i', 16, 32) | onechar('t', 24, 32):
			switch(in[4]){
			case onechar('c', 0, 8):
				switch(in[5]){
				case onechar('h', 0, 8):
					return gtok_t_switches::SWITCH;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <switches>.");
}

inline gtok_t_segments lex_node_t_segments(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 7:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('s', 0, 32) | onechar('e', 8, 32) | onechar('g', 16, 32) | onechar('m', 24, 32):
			switch(in[4]){
			case onechar('e', 0, 8):
				switch(in[5]){
				case onechar('n', 0, 8):
					switch(in[6]){
					case onechar('t', 0, 8):
						return gtok_t_segments::SEGMENT;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <segments>.");
}

inline gtok_t_block_types lex_node_t_block_types(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 10:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('b', 0, 64) | onechar('l', 8, 64) | onechar('o', 16, 64) | onechar('c', 24, 64) | onechar('k', 32, 64) | onechar('_', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
			switch(in[8]){
			case onechar('p', 0, 8):
				switch(in[9]){
				case onechar('e', 0, 8):
					return gtok_t_block_types::BLOCK_TYPE;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <block_types>.");
}

inline gtok_t_grid_locs lex_node_t_grid_locs(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('g', 0, 64) | onechar('r', 8, 64) | onechar('i', 16, 64) | onechar('d', 24, 64) | onechar('_', 32, 64) | onechar('l', 40, 64) | onechar('o', 48, 64) | onechar('c', 56, 64):
			return gtok_t_grid_locs::GRID_LOC;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <grid_locs>.");
}

inline gtok_t_rr_nodes lex_node_t_rr_nodes(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('n', 0, 32) | onechar('o', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
			return gtok_t_rr_nodes::NODE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <rr_nodes>.");
}

inline gtok_t_rr_edges lex_node_t_rr_edges(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('e', 0, 32) | onechar('d', 8, 32) | onechar('g', 16, 32) | onechar('e', 24, 32):
			return gtok_t_rr_edges::EDGE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <rr_edges>.");
}

inline atok_t_bin_nodes lex_attr_t_bin_nodes(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('f', 0, 32) | onechar('i', 8, 32) | onechar('l', 16, 32) | onechar('e', 24, 32):
			return atok_t_bin_nodes::FILE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <bin_nodes>.");
}

inline atok_t_connection_box lex_attr_t_connection_box(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('i', 0, 8):
			switch(in[1]){
			case onechar('d', 0, 8):
				return atok_t_connection_box::ID;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
			return atok_t_connection_box::NAME;
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <connection_box>.");
}

inline gtok_t_connection_boxes lex_node_t_connection_boxes(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 14:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('o', 8, 64) | onechar('n', 16, 64) | onechar('n', 24, 64) | onechar('e', 32, 64) | onechar('c', 40, 64) | onechar('t', 48, 64) | onechar('i', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('o', 0, 32) | onechar('n', 8, 32) | onechar('_', 16, 32) | onechar('b', 24, 32):
				switch(in[12]){
				case onechar('o', 0, 8):
					switch(in[13]){
					case onechar('x', 0, 8):
						return gtok_t_connection_boxes::CONNECTION_BOX;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <connection_boxes>.");
}
inline atok_t_connection_boxes lex_attr_t_connection_boxes(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('d', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('m', 0, 8):
				return atok_t_connection_boxes::X_DIM;
			break;
			default: break;
			}
		break;
		case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('d', 16, 32) | onechar('i', 24, 32):
			switch(in[4]){
			case onechar('m', 0, 8):
				return atok_t_connection_boxes::Y_DIM;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('n', 0, 64) | onechar('u', 8, 64) | onechar('m', 16, 64) | onechar('_', 24, 64) | onechar('b', 32, 64) | onechar('o', 40, 64) | onechar('x', 48, 64) | onechar('e', 56, 64):
			switch(in[8]){
			case onechar('s', 0, 8):
				return atok_t_connection_boxes::NUM_BOXES;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <connection_boxes>.");
}

inline gtok_t_rr_graph lex_node_t_rr_graph(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('g', 0, 32) | onechar('r', 8, 32) | onechar('i', 16, 32) | onechar('d', 24, 32):
			return gtok_t_rr_graph::GRID;
		break;
		default: break;
		}
		break;
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('h', 8, 64) | onechar('a', 16, 64) | onechar('n', 24, 64) | onechar('n', 32, 64) | onechar('e', 40, 64) | onechar('l', 48, 64) | onechar('s', 56, 64):
			return gtok_t_rr_graph::CHANNELS;
		break;
		case onechar('r', 0, 64) | onechar('r', 8, 64) | onechar('_', 16, 64) | onechar('e', 24, 64) | onechar('d', 32, 64) | onechar('g', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
			return gtok_t_rr_graph::RR_EDGES;
		break;
		case onechar('r', 0, 64) | onechar('r', 8, 64) | onechar('_', 16, 64) | onechar('n', 24, 64) | onechar('o', 32, 64) | onechar('d', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
			return gtok_t_rr_graph::RR_NODES;
		break;
		case onechar('s', 0, 64) | onechar('e', 8, 64) | onechar('g', 16, 64) | onechar('m', 24, 64) | onechar('e', 32, 64) | onechar('n', 40, 64) | onechar('t', 48, 64) | onechar('s', 56, 64):
			return gtok_t_rr_graph::SEGMENTS;
		break;
		case onechar('s', 0, 64) | onechar('w', 8, 64) | onechar('i', 16, 64) | onechar('t', 24, 64) | onechar('c', 32, 64) | onechar('h', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
			return gtok_t_rr_graph::SWITCHES;
		break;
		default: break;
		}
		break;
	case 11:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('b', 0, 64) | onechar('l', 8, 64) | onechar('o', 16, 64) | onechar('c', 24, 64) | onechar('k', 32, 64) | onechar('_', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
			switch(in[8]){
			case onechar('p', 0, 8):
				switch(in[9]){
				case onechar('e', 0, 8):
					switch(in[10]){
					case onechar('s', 0, 8):
						return gtok_t_rr_graph::BLOCK_TYPES;
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 16:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('c', 0, 64) | onechar('o', 8, 64) | onechar('n', 16, 64) | onechar('n', 24, 64) | onechar('e', 32, 64) | onechar('c', 40, 64) | onechar('t', 48, 64) | onechar('i', 56, 64):
			switch(*((triehash_uu64*)&in[8])){
			case onechar('o', 0, 64) | onechar('n', 8, 64) | onechar('_', 16, 64) | onechar('b', 24, 64) | onechar('o', 32, 64) | onechar('x', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
				return gtok_t_rr_graph::CONNECTION_BOXES;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 22:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('b', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('a', 24, 64) | onechar('r', 32, 64) | onechar('y', 40, 64) | onechar('_', 48, 64) | onechar('n', 56, 64):
			switch(*((triehash_uu64*)&in[8])){
			case onechar('o', 0, 64) | onechar('d', 8, 64) | onechar('e', 16, 64) | onechar('s', 24, 64) | onechar('_', 32, 64) | onechar('a', 40, 64) | onechar('n', 48, 64) | onechar('d', 56, 64):
				switch(*((triehash_uu32*)&in[16])){
				case onechar('_', 0, 32) | onechar('e', 8, 32) | onechar('d', 16, 32) | onechar('g', 24, 32):
					switch(in[20]){
					case onechar('e', 0, 8):
						switch(in[21]){
						case onechar('s', 0, 8):
							return gtok_t_rr_graph::BINARY_NODES_AND_EDGES;
						break;
						default: break;
						}
					break;
					default: break;
					}
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <rr_graph>.");
}
inline atok_t_rr_graph lex_attr_t_rr_graph(const char *in){
	unsigned int len = strlen(in);
	switch(len){
	case 9:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('t', 0, 64) | onechar('o', 8, 64) | onechar('o', 16, 64) | onechar('l', 24, 64) | onechar('_', 32, 64) | onechar('n', 40, 64) | onechar('a', 48, 64) | onechar('m', 56, 64):
			switch(in[8]){
			case onechar('e', 0, 8):
				return atok_t_rr_graph::TOOL_NAME;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 12:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('t', 0, 64) | onechar('o', 8, 64) | onechar('o', 16, 64) | onechar('l', 24, 64) | onechar('_', 32, 64) | onechar('c', 40, 64) | onechar('o', 48, 64) | onechar('m', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('m', 0, 32) | onechar('e', 8, 32) | onechar('n', 16, 32) | onechar('t', 24, 32):
				return atok_t_rr_graph::TOOL_COMMENT;
			break;
			default: break;
			}
		break;
		case onechar('t', 0, 64) | onechar('o', 8, 64) | onechar('o', 16, 64) | onechar('l', 24, 64) | onechar('_', 32, 64) | onechar('v', 40, 64) | onechar('e', 48, 64) | onechar('r', 56, 64):
			switch(*((triehash_uu32*)&in[8])){
			case onechar('s', 0, 32) | onechar('i', 8, 32) | onechar('o', 16, 32) | onechar('n', 24, 32):
				return atok_t_rr_graph::TOOL_VERSION;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <rr_graph>.");
}

/**
 * Internal error function for xs:choice and xs:sequence validators.
 */
void dfa_error(const char *wrong, int *states, const char **lookup, int len);

/**
 * Internal error function for xs:all validators.
 */
template<std::size_t N>
void all_error(std::bitset<N> gstate, const char **lookup);

/**
 * Internal error function for attribute validators.
 */
template<std::size_t N>
void attr_error(std::bitset<N> astate, const char **lookup);


/* Internal loading functions, which validate and load a PugiXML DOM tree into memory. */
void load_channel(const pugi::xml_node &root, t_channel *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <channel>.");

	std::bitset<5> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_channel in = lex_attr_t_channel(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <channel>.");
		switch(in){
		case atok_t_channel::CHAN_WIDTH_MAX:
			out->chan_width_max = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->chan_width_max.");
			break;
		case atok_t_channel::X_MAX:
			out->x_max = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->x_max.");
			break;
		case atok_t_channel::X_MIN:
			out->x_min = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->x_min.");
			break;
		case atok_t_channel::Y_MAX:
			out->y_max = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->y_max.");
			break;
		case atok_t_channel::Y_MIN:
			out->y_min = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->y_min.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<5> test_astate = astate | std::bitset<5>(0b00000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_channel);
}

void load_x_list(const pugi::xml_node &root, t_x_list *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <x_list>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_x_list in = lex_attr_t_x_list(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <x_list>.");
		switch(in){
		case atok_t_x_list::INDEX:
			out->index = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->index.");
			break;
		case atok_t_x_list::INFO:
			out->info = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->info.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_x_list);
}

void load_y_list(const pugi::xml_node &root, t_y_list *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <y_list>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_y_list in = lex_attr_t_y_list(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <y_list>.");
		switch(in){
		case atok_t_y_list::INDEX:
			out->index = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->index.");
			break;
		case atok_t_y_list::INFO:
			out->info = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->info.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_y_list);
}

void load_timing(const pugi::xml_node &root, t_timing *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <timing>.");

	std::bitset<5> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_timing in = lex_attr_t_timing(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <timing>.");
		switch(in){
		case atok_t_timing::CIN:
			out->Cin = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->Cin.");
			break;
		case atok_t_timing::CINTERNAL:
			out->Cinternal = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->Cinternal.");
			break;
		case atok_t_timing::COUT:
			out->Cout = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->Cout.");
			break;
		case atok_t_timing::R:
			out->R = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->R.");
			break;
		case atok_t_timing::TDEL:
			out->Tdel = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->Tdel.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<5> test_astate = astate | std::bitset<5>(0b00000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_timing);
}

void load_sizing(const pugi::xml_node &root, t_sizing *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <sizing>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_sizing in = lex_attr_t_sizing(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <sizing>.");
		switch(in){
		case atok_t_sizing::BUF_SIZE:
			out->buf_size = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->buf_size.");
			break;
		case atok_t_sizing::MUX_TRANS_SIZE:
			out->mux_trans_size = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->mux_trans_size.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_sizing);
}

void load_switch(const pugi::xml_node &root, t_switch *out){
	std::bitset<2> gstate = 0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_switch in = lex_node_t_switch(node.name());
		if(gstate[(int)in] == 0) gstate[(int)in] = 1;
		else throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <switch>.");
		switch(in){
		case gtok_t_switch::TIMING:
			load_timing(node, &out->timing);
			out->has_timing = 1;
			break;
		case gtok_t_switch::SIZING:
			load_sizing(node, &out->sizing);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_gstate = gstate | std::bitset<2>(0b01);
	if(!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_switch);

	std::bitset<3> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_switch in = lex_attr_t_switch(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <switch>.");
		switch(in){
		case atok_t_switch::ID:
			out->id = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->id.");
			break;
		case atok_t_switch::NAME:
			out->name = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->name.");
			break;
		case atok_t_switch::TYPE:
			out->type = lex_enum_switch_type(attr.value(), true);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<3> test_astate = astate | std::bitset<3>(0b100);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_switch);
}

void load_segment_timing(const pugi::xml_node &root, t_segment_timing *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <segment_timing>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_segment_timing in = lex_attr_t_segment_timing(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <segment_timing>.");
		switch(in){
		case atok_t_segment_timing::C_PER_METER:
			out->C_per_meter = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->C_per_meter.");
			break;
		case atok_t_segment_timing::R_PER_METER:
			out->R_per_meter = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->R_per_meter.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b11);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_segment_timing);
}

void load_segment(const pugi::xml_node &root, t_segment *out){
	std::bitset<1> gstate = 0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_segment in = lex_node_t_segment(node.name());
		if(gstate[(int)in] == 0) gstate[(int)in] = 1;
		else throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <segment>.");
		switch(in){
		case gtok_t_segment::TIMING:
			load_segment_timing(node, &out->timing);
			out->has_timing = 1;
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_gstate = gstate | std::bitset<1>(0b1);
	if(!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_segment);

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_segment in = lex_attr_t_segment(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <segment>.");
		switch(in){
		case atok_t_segment::ID:
			out->id = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->id.");
			break;
		case atok_t_segment::NAME:
			out->name = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->name.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_segment);
}

void load_pin(const pugi::xml_node &root, t_pin *out){
	out->value = char_pool.add(root.child_value());
	if(errno != 0)
		throw std::runtime_error("Invalid value `" + std::string(root.child_value()) + "` to load a const char * into out->value.");

	std::bitset<1> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_pin in = lex_attr_t_pin(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <pin>.");
		switch(in){
		case atok_t_pin::PTC:
			out->ptc = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->ptc.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_pin);
}

static const int NUM_T_PIN_CLASS_STATES = 2;
static const int NUM_T_PIN_CLASS_INPUTS = 1;
int gstate_t_pin_class[NUM_T_PIN_CLASS_STATES][NUM_T_PIN_CLASS_INPUTS] = {
	{0},
	{0},
};
void load_pin_class(const pugi::xml_node &root, t_pin_class *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_pin_class in = lex_node_t_pin_class(node.name());
		next = gstate_t_pin_class[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_pin_class[(int)in], gstate_t_pin_class[state], gtok_lookup_t_pin_class, 1);
		state = next;
		switch(in){
		case gtok_t_pin_class::PIN:
			out->pins.push_back(t_pin());
			load_pin(node, &out->pins.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_pin_class[state], gtok_lookup_t_pin_class, 1);

	std::bitset<1> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_pin_class in = lex_attr_t_pin_class(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <pin_class>.");
		switch(in){
		case atok_t_pin_class::TYPE:
			out->type = lex_enum_pin_type(attr.value(), true);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_pin_class);
}

void load_meta(const pugi::xml_node &root, t_meta *out){
	out->value = char_pool.add(root.child_value());
	if(errno != 0)
		throw std::runtime_error("Invalid value `" + std::string(root.child_value()) + "` to load a const char * into out->value.");

	std::bitset<1> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_meta in = lex_attr_t_meta(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <meta>.");
		switch(in){
		case atok_t_meta::NAME:
			out->name = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->name.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_meta);
}

static const int NUM_T_METADATA_STATES = 2;
static const int NUM_T_METADATA_INPUTS = 1;
int gstate_t_metadata[NUM_T_METADATA_STATES][NUM_T_METADATA_INPUTS] = {
	{0},
	{0},
};
void load_metadata(const pugi::xml_node &root, t_metadata *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_metadata in = lex_node_t_metadata(node.name());
		next = gstate_t_metadata[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_metadata[(int)in], gstate_t_metadata[state], gtok_lookup_t_metadata, 1);
		state = next;
		switch(in){
		case gtok_t_metadata::META:
			out->metas.push_back(t_meta());
			load_meta(node, &out->metas.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_metadata[state], gtok_lookup_t_metadata, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <metadata>.");
}

static const int NUM_T_BLOCK_TYPE_STATES = 1;
static const int NUM_T_BLOCK_TYPE_INPUTS = 1;
int gstate_t_block_type[NUM_T_BLOCK_TYPE_STATES][NUM_T_BLOCK_TYPE_INPUTS] = {
	{0},
};
void load_block_type(const pugi::xml_node &root, t_block_type *out){
	int next, state=0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_block_type in = lex_node_t_block_type(node.name());
		next = gstate_t_block_type[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_block_type[(int)in], gstate_t_block_type[state], gtok_lookup_t_block_type, 1);
		state = next;
		switch(in){
		case gtok_t_block_type::PIN_CLASS:
			out->pin_classes.push_back(t_pin_class());
			load_pin_class(node, &out->pin_classes.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_block_type[state], gtok_lookup_t_block_type, 1);

	std::bitset<4> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_block_type in = lex_attr_t_block_type(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <block_type>.");
		switch(in){
		case atok_t_block_type::HEIGHT:
			out->height = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->height.");
			break;
		case atok_t_block_type::ID:
			out->id = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->id.");
			break;
		case atok_t_block_type::NAME:
			out->name = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->name.");
			break;
		case atok_t_block_type::WIDTH:
			out->width = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->width.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<4> test_astate = astate | std::bitset<4>(0b0000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_block_type);
}

void load_grid_loc(const pugi::xml_node &root, t_grid_loc *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <grid_loc>.");

	std::bitset<5> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_grid_loc in = lex_attr_t_grid_loc(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <grid_loc>.");
		switch(in){
		case atok_t_grid_loc::BLOCK_TYPE_ID:
			out->block_type_id = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->block_type_id.");
			break;
		case atok_t_grid_loc::HEIGHT_OFFSET:
			out->height_offset = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->height_offset.");
			break;
		case atok_t_grid_loc::WIDTH_OFFSET:
			out->width_offset = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->width_offset.");
			break;
		case atok_t_grid_loc::X:
			out->x = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->x.");
			break;
		case atok_t_grid_loc::Y:
			out->y = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->y.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<5> test_astate = astate | std::bitset<5>(0b00000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_grid_loc);
}

void load_node_loc(const pugi::xml_node &root, t_node_loc *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <node_loc>.");

	std::bitset<6> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_node_loc in = lex_attr_t_node_loc(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_loc>.");
		switch(in){
		case atok_t_node_loc::PTC:
			out->ptc = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->ptc.");
			break;
		case atok_t_node_loc::SIDE:
			out->side = lex_enum_loc_side(attr.value(), true);
			break;
		case atok_t_node_loc::XHIGH:
			out->xhigh = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->xhigh.");
			break;
		case atok_t_node_loc::XLOW:
			out->xlow = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->xlow.");
			break;
		case atok_t_node_loc::YHIGH:
			out->yhigh = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->yhigh.");
			break;
		case atok_t_node_loc::YLOW:
			out->ylow = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->ylow.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<6> test_astate = astate | std::bitset<6>(0b000010);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_loc);
}

void load_node_timing(const pugi::xml_node &root, t_node_timing *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <node_timing>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_node_timing in = lex_attr_t_node_timing(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_timing>.");
		switch(in){
		case atok_t_node_timing::C:
			out->C = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->C.");
			break;
		case atok_t_node_timing::R:
			out->R = std::strtof(attr.value(), NULL);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a float into out->R.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_timing);
}

void load_node_segment(const pugi::xml_node &root, t_node_segment *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <node_segment>.");

	std::bitset<1> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_node_segment in = lex_attr_t_node_segment(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_segment>.");
		switch(in){
		case atok_t_node_segment::SEGMENT_ID:
			out->segment_id = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->segment_id.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_segment);
}

void load_node_connection_box(const pugi::xml_node &root, t_node_connection_box *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <node_connection_box>.");

	std::bitset<3> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_node_connection_box in = lex_attr_t_node_connection_box(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_connection_box>.");
		switch(in){
		case atok_t_node_connection_box::ID:
			out->id = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->id.");
			break;
		case atok_t_node_connection_box::X:
			out->x = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->x.");
			break;
		case atok_t_node_connection_box::Y:
			out->y = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->y.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<3> test_astate = astate | std::bitset<3>(0b000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_connection_box);
}

void load_node_canonical_loc(const pugi::xml_node &root, t_node_canonical_loc *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <node_canonical_loc>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_node_canonical_loc in = lex_attr_t_node_canonical_loc(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_canonical_loc>.");
		switch(in){
		case atok_t_node_canonical_loc::X:
			out->x = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->x.");
			break;
		case atok_t_node_canonical_loc::Y:
			out->y = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->y.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_canonical_loc);
}

void load_node(const pugi::xml_node &root, t_node *out){
	std::bitset<6> gstate = 0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_node in = lex_node_t_node(node.name());
		if(gstate[(int)in] == 0) gstate[(int)in] = 1;
		else throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <node>.");
		switch(in){
		case gtok_t_node::LOC:
			load_node_loc(node, &out->loc);
			break;
		case gtok_t_node::TIMING:
			load_node_timing(node, &out->timing);
			out->has_timing = 1;
			break;
		case gtok_t_node::SEGMENT:
			load_node_segment(node, &out->segment);
			out->has_segment = 1;
			break;
		case gtok_t_node::CONNECTION_BOX:
			load_node_connection_box(node, &out->connection_box);
			out->has_connection_box = 1;
			break;
		case gtok_t_node::CANONICAL_LOC:
			load_node_canonical_loc(node, &out->canonical_loc);
			out->has_canonical_loc = 1;
			break;
		case gtok_t_node::METADATA:
			load_metadata(node, &out->metadata);
			out->has_metadata = 1;
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<6> test_gstate = gstate | std::bitset<6>(0b111110);
	if(!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_node);

	std::bitset<4> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_node in = lex_attr_t_node(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node>.");
		switch(in){
		case atok_t_node::CAPACITY:
			out->capacity = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->capacity.");
			break;
		case atok_t_node::DIRECTION:
			out->direction = lex_enum_node_direction(attr.value(), true);
			break;
		case atok_t_node::ID:
			out->id = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->id.");
			break;
		case atok_t_node::TYPE:
			out->type = lex_enum_node_type(attr.value(), true);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<4> test_astate = astate | std::bitset<4>(0b0010);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_node);
}

void load_edge(const pugi::xml_node &root, t_edge *out){
	std::bitset<1> gstate = 0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_edge in = lex_node_t_edge(node.name());
		if(gstate[(int)in] == 0) gstate[(int)in] = 1;
		else throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <edge>.");
		switch(in){
		case gtok_t_edge::METADATA:
			load_metadata(node, &out->metadata);
			out->has_metadata = 1;
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_gstate = gstate | std::bitset<1>(0b1);
	if(!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_edge);

	std::bitset<4> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_edge in = lex_attr_t_edge(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <edge>.");
		switch(in){
		case atok_t_edge::ID:
			out->id = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->id.");
			break;
		case atok_t_edge::SINK_NODE:
			out->sink_node = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->sink_node.");
			break;
		case atok_t_edge::SRC_NODE:
			out->src_node = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->src_node.");
			break;
		case atok_t_edge::SWITCH_ID:
			out->switch_id = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->switch_id.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<4> test_astate = astate | std::bitset<4>(0b0001);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_edge);
}

static const int NUM_T_CHANNELS_STATES = 4;
static const int NUM_T_CHANNELS_INPUTS = 3;
int gstate_t_channels[NUM_T_CHANNELS_STATES][NUM_T_CHANNELS_INPUTS] = {
	{-1, -1, 0},
	{-1, 1, 0},
	{-1, 1, -1},
	{2, -1, -1},
};
void load_channels(const pugi::xml_node &root, t_channels *out){
	int next, state=3;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_channels in = lex_node_t_channels(node.name());
		next = gstate_t_channels[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_channels[(int)in], gstate_t_channels[state], gtok_lookup_t_channels, 3);
		state = next;
		switch(in){
		case gtok_t_channels::CHANNEL:
			load_channel(node, &out->channel);
			break;
		case gtok_t_channels::X_LIST:
			out->x_lists.push_back(t_x_list());
			load_x_list(node, &out->x_lists.back());
			break;
		case gtok_t_channels::Y_LIST:
			out->y_lists.push_back(t_y_list());
			load_y_list(node, &out->y_lists.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_channels[state], gtok_lookup_t_channels, 3);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <channels>.");
}

static const int NUM_T_SWITCHES_STATES = 2;
static const int NUM_T_SWITCHES_INPUTS = 1;
int gstate_t_switches[NUM_T_SWITCHES_STATES][NUM_T_SWITCHES_INPUTS] = {
	{0},
	{0},
};
void load_switches(const pugi::xml_node &root, t_switches *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_switches in = lex_node_t_switches(node.name());
		next = gstate_t_switches[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_switches[(int)in], gstate_t_switches[state], gtok_lookup_t_switches, 1);
		state = next;
		switch(in){
		case gtok_t_switches::SWITCH:
			out->switches.push_back(t_switch());
			load_switch(node, &out->switches.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_switches[state], gtok_lookup_t_switches, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <switches>.");
}

static const int NUM_T_SEGMENTS_STATES = 2;
static const int NUM_T_SEGMENTS_INPUTS = 1;
int gstate_t_segments[NUM_T_SEGMENTS_STATES][NUM_T_SEGMENTS_INPUTS] = {
	{0},
	{0},
};
void load_segments(const pugi::xml_node &root, t_segments *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_segments in = lex_node_t_segments(node.name());
		next = gstate_t_segments[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_segments[(int)in], gstate_t_segments[state], gtok_lookup_t_segments, 1);
		state = next;
		switch(in){
		case gtok_t_segments::SEGMENT:
			out->segments.push_back(t_segment());
			load_segment(node, &out->segments.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_segments[state], gtok_lookup_t_segments, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <segments>.");
}

static const int NUM_T_BLOCK_TYPES_STATES = 2;
static const int NUM_T_BLOCK_TYPES_INPUTS = 1;
int gstate_t_block_types[NUM_T_BLOCK_TYPES_STATES][NUM_T_BLOCK_TYPES_INPUTS] = {
	{0},
	{0},
};
void load_block_types(const pugi::xml_node &root, t_block_types *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_block_types in = lex_node_t_block_types(node.name());
		next = gstate_t_block_types[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_block_types[(int)in], gstate_t_block_types[state], gtok_lookup_t_block_types, 1);
		state = next;
		switch(in){
		case gtok_t_block_types::BLOCK_TYPE:
			out->block_types.push_back(t_block_type());
			load_block_type(node, &out->block_types.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_block_types[state], gtok_lookup_t_block_types, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <block_types>.");
}

static const int NUM_T_GRID_LOCS_STATES = 2;
static const int NUM_T_GRID_LOCS_INPUTS = 1;
int gstate_t_grid_locs[NUM_T_GRID_LOCS_STATES][NUM_T_GRID_LOCS_INPUTS] = {
	{0},
	{0},
};
void load_grid_locs(const pugi::xml_node &root, t_grid_locs *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_grid_locs in = lex_node_t_grid_locs(node.name());
		next = gstate_t_grid_locs[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_grid_locs[(int)in], gstate_t_grid_locs[state], gtok_lookup_t_grid_locs, 1);
		state = next;
		switch(in){
		case gtok_t_grid_locs::GRID_LOC:
			out->grid_locs.push_back(t_grid_loc());
			load_grid_loc(node, &out->grid_locs.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_grid_locs[state], gtok_lookup_t_grid_locs, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <grid_locs>.");
}

static const int NUM_T_RR_NODES_STATES = 2;
static const int NUM_T_RR_NODES_INPUTS = 1;
int gstate_t_rr_nodes[NUM_T_RR_NODES_STATES][NUM_T_RR_NODES_INPUTS] = {
	{0},
	{0},
};
void load_rr_nodes(const pugi::xml_node &root, t_rr_nodes *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_rr_nodes in = lex_node_t_rr_nodes(node.name());
		next = gstate_t_rr_nodes[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_rr_nodes[(int)in], gstate_t_rr_nodes[state], gtok_lookup_t_rr_nodes, 1);
		state = next;
		switch(in){
		case gtok_t_rr_nodes::NODE:
			out->nodes.push_back(t_node());
			load_node(node, &out->nodes.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_rr_nodes[state], gtok_lookup_t_rr_nodes, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <rr_nodes>.");
}

static const int NUM_T_RR_EDGES_STATES = 2;
static const int NUM_T_RR_EDGES_INPUTS = 1;
int gstate_t_rr_edges[NUM_T_RR_EDGES_STATES][NUM_T_RR_EDGES_INPUTS] = {
	{0},
	{0},
};
void load_rr_edges(const pugi::xml_node &root, t_rr_edges *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_rr_edges in = lex_node_t_rr_edges(node.name());
		next = gstate_t_rr_edges[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_rr_edges[(int)in], gstate_t_rr_edges[state], gtok_lookup_t_rr_edges, 1);
		state = next;
		switch(in){
		case gtok_t_rr_edges::EDGE:
			out->edges.push_back(t_edge());
			load_edge(node, &out->edges.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_rr_edges[state], gtok_lookup_t_rr_edges, 1);

	if(root.first_attribute())
		throw std::runtime_error("Unexpected attribute in <rr_edges>.");
}

void load_bin_nodes(const pugi::xml_node &root, t_bin_nodes *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <bin_nodes>.");

	std::bitset<1> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_bin_nodes in = lex_attr_t_bin_nodes(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <bin_nodes>.");
		switch(in){
		case atok_t_bin_nodes::FILE:
			out->file = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->file.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<1> test_astate = astate | std::bitset<1>(0b1);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_bin_nodes);
}

void load_connection_box(const pugi::xml_node &root, t_connection_box *out){
	if(root.first_child().type() == pugi::node_element)
		throw std::runtime_error("Unexpected child element in <connection_box>.");

	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_connection_box in = lex_attr_t_connection_box(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <connection_box>.");
		switch(in){
		case atok_t_connection_box::ID:
			out->id = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->id.");
			break;
		case atok_t_connection_box::NAME:
			out->name = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->name.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_connection_box);
}

static const int NUM_T_CONNECTION_BOXES_STATES = 2;
static const int NUM_T_CONNECTION_BOXES_INPUTS = 1;
int gstate_t_connection_boxes[NUM_T_CONNECTION_BOXES_STATES][NUM_T_CONNECTION_BOXES_INPUTS] = {
	{0},
	{0},
};
void load_connection_boxes(const pugi::xml_node &root, t_connection_boxes *out){
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_connection_boxes in = lex_node_t_connection_boxes(node.name());
		next = gstate_t_connection_boxes[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_connection_boxes[(int)in], gstate_t_connection_boxes[state], gtok_lookup_t_connection_boxes, 1);
		state = next;
		switch(in){
		case gtok_t_connection_boxes::CONNECTION_BOX:
			out->connection_boxes.push_back(t_connection_box());
			load_connection_box(node, &out->connection_boxes.back());
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_connection_boxes[state], gtok_lookup_t_connection_boxes, 1);

	std::bitset<3> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_connection_boxes in = lex_attr_t_connection_boxes(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <connection_boxes>.");
		switch(in){
		case atok_t_connection_boxes::NUM_BOXES:
			out->num_boxes = std::strtoul(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a unsigned int into out->num_boxes.");
			break;
		case atok_t_connection_boxes::X_DIM:
			out->x_dim = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->x_dim.");
			break;
		case atok_t_connection_boxes::Y_DIM:
			out->y_dim = std::strtol(attr.value(), NULL, 10);
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a int into out->y_dim.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<3> test_astate = astate | std::bitset<3>(0b000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_connection_boxes);
}

void load_rr_graph(const pugi::xml_node &root, t_rr_graph *out){
	std::bitset<9> gstate = 0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		gtok_t_rr_graph in = lex_node_t_rr_graph(node.name());
		if(gstate[(int)in] == 0) gstate[(int)in] = 1;
		else throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <rr_graph>.");
		switch(in){
		case gtok_t_rr_graph::BINARY_NODES_AND_EDGES:
			load_bin_nodes(node, &out->binary_nodes_and_edges);
			out->has_binary_nodes_and_edges = 1;
			break;
		case gtok_t_rr_graph::CONNECTION_BOXES:
			load_connection_boxes(node, &out->connection_boxes);
			out->has_connection_boxes = 1;
			break;
		case gtok_t_rr_graph::CHANNELS:
			load_channels(node, &out->channels);
			break;
		case gtok_t_rr_graph::SWITCHES:
			load_switches(node, &out->switches);
			break;
		case gtok_t_rr_graph::SEGMENTS:
			load_segments(node, &out->segments);
			break;
		case gtok_t_rr_graph::BLOCK_TYPES:
			load_block_types(node, &out->block_types);
			break;
		case gtok_t_rr_graph::GRID:
			load_grid_locs(node, &out->grid);
			break;
		case gtok_t_rr_graph::RR_NODES:
			load_rr_nodes(node, &out->rr_nodes);
			break;
		case gtok_t_rr_graph::RR_EDGES:
			load_rr_edges(node, &out->rr_edges);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<9> test_gstate = gstate | std::bitset<9>(0b000000011);
	if(!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_rr_graph);

	std::bitset<3> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_rr_graph in = lex_attr_t_rr_graph(attr.name());
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <rr_graph>.");
		switch(in){
		case atok_t_rr_graph::TOOL_COMMENT:
			out->tool_comment = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->tool_comment.");
			break;
		case atok_t_rr_graph::TOOL_NAME:
			out->tool_name = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->tool_name.");
			break;
		case atok_t_rr_graph::TOOL_VERSION:
			out->tool_version = char_pool.add(attr.value());
			if(errno != 0)
				throw std::runtime_error("Invalid value `" + std::string(attr.value()) + "` to load a const char * into out->tool_version.");
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<3> test_astate = astate | std::bitset<3>(0b111);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_rr_graph);
}

void dfa_error(const char *wrong, int *states, const char **lookup, int len){
	std::vector<std::string> expected;
	for(int i=0; i<len; i++){
		if(states[i] != -1) expected.push_back(lookup[i]);
	}

	std::string expected_or = expected[0];
	for(unsigned int i=1; i<expected.size(); i++)
		expected_or += std::string(" or ") + expected[i];

	throw std::runtime_error("Expected " + expected_or + ", found " + std::string(wrong));
}

template<std::size_t N>
void all_error(std::bitset<N> gstate, const char **lookup){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(gstate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	throw std::runtime_error("Didn't find required elements " + missing_and + ".");
}

template<std::size_t N>
void attr_error(std::bitset<N> astate, const char **lookup){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(astate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	throw std::runtime_error("Didn't find required attributes " + missing_and + ".");
}

} /* namespace uxsd */
